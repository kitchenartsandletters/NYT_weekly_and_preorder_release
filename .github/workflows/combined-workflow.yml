name: Preorder Management and Weekly Report

permissions:
  contents: write
  issues: write

on:
  # Run every Friday for preorder identification and approval creation
  schedule:
    - cron: '0 5 * * 0'  # Midnight on Sunday
    - cron: '0 16 * * 1'  # Noon on Monday
  
  # Allow manual trigger with options
  workflow_dispatch:
    inputs:
      workflow_type:
        description: 'Workflow type to run'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - identify-preorders
          - generate-report
      run_mode:
        description: 'Run mode'
        required: true
        default: 'test'
        type: choice
        options:
          - test
          - production
      issue_number:
        description: 'Issue number for manual approval (leave empty for automatic)'
        required: false
      isbn_list:
        description: 'Comma-separated list of ISBNs to approve (overrides issue)'
        required: false

jobs:
  determine-job:
    runs-on: ubuntu-latest
    outputs:
      job_type: ${{ steps.set-job.outputs.job_type }}
      day_of_week: ${{ steps.set-job.outputs.day_of_week }}
    steps:
      - name: Determine job type based on day or manual input
        id: set-job
        run: |
          # Get current day of week (1=Monday ... 7=Sunday)
          DAY_OF_WEEK=$(date +%u)
          echo "day_of_week=$DAY_OF_WEEK" >> $GITHUB_OUTPUT

          job_type="none"
          if [[ "${{ github.event_name }}" == "schedule" ]]; then
            if [[ "$DAY_OF_WEEK" == "5" ]]; then
              job_type="identify-preorders"
            elif [[ "$DAY_OF_WEEK" == "1" || "$DAY_OF_WEEK" == "7" ]]; then
              job_type="generate-report"
            fi
          else
            job_type="${{ github.event.inputs.workflow_type }}"
          fi
      
          echo "job_type=$job_type" >> $GITHUB_OUTPUT
          echo "Determined job type: $job_type"

  identify-preorders:
    needs: determine-job
    if: needs.determine-job.outputs.job_type == 'identify-preorders' || needs.determine-job.outputs.job_type == 'full'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Create environment file
        run: |
          echo "SHOP_URL=${{ secrets.SHOP_URL }}" > .env.production
          echo "SHOPIFY_ACCESS_TOKEN=${{ secrets.SHOPIFY_ACCESS_TOKEN }}" >> .env.production
          echo "MAILTRAP_API_TOKEN=${{ secrets.MAILTRAP_API_TOKEN }}" >> .env.production
          echo "EMAIL_SENDER=${{ secrets.EMAIL_SENDER }}" >> .env.production
          echo "EMAIL_RECIPIENTS=${{ secrets.EMAIL_RECIPIENTS }}" >> .env.production
          
          # Set test mode based on input parameter
          if [ "${{ github.event.inputs.run_mode }}" = "test" ]; then
            echo "USE_TEST_DATA=true" >> .env.production
            echo "🧪 Running in TEST mode"
          else
            echo "USE_TEST_DATA=false" >> .env.production
            echo "🚀 Running in PRODUCTION mode"
          fi

      - name: Dump NYT preorder tracking file for debugging
        run: |
          echo "===== START NYT preorder tracking CSV ====="
          cat preorders/NYT_preorder_tracking.csv
          echo "===== END NYT preorder tracking CSV ====="
      
      - name: Run publication date audit
        id: run-audit
        run: |
          mkdir -p output audit overrides
          TIMESTAMP=$(date +'%Y-%m-%d')
          RELEASES_FILE="./output/pending_releases_${TIMESTAMP}.json"
          
          # Ensure audit_publication_dates.py outputs all required fields in the JSON
          if [ "${{ github.event.inputs.run_mode }}" = "test" ]; then
            python -u audit_publication_dates.py --output-releases "$RELEASES_FILE" --test-mode || true
          else
            python -u audit_publication_dates.py --output-releases "$RELEASES_FILE"
          fi
          
          if [ -f "$RELEASES_FILE" ]; then
            echo "releases_file=$RELEASES_FILE" >> $GITHUB_OUTPUT
            echo "has_pending_releases=true" >> $GITHUB_OUTPUT
          else
            echo "has_pending_releases=false" >> $GITHUB_OUTPUT
          fi

      - name: Run preorder manager
        run: |
          python -u preorderManager.py

      - name: Run weekly delta log
        run: |
          python -u generate_weekly_delta_log.py

      - name: Notify admin on releases
        run: |
          python -u notify_admin_on_release.py
      
      - name: Create fallback pending releases if needed
        id: create-fallback
        if: steps.run-audit.outputs.has_pending_releases != 'true'
        run: |
          mkdir -p output
          TIMESTAMP=$(date +'%Y-%m-%d')
          FALLBACK_FILE="./output/pending_releases_${TIMESTAMP}.json"
          
          # Create a minimal test file
          echo '{
            "pending_releases": [
              {
                "isbn": "9780262551311",
                "title": "Test Book 1",
                "quantity": 2,
                "pub_date": "'$TIMESTAMP'"
              },
              {
                "isbn": "9784756256522",
                "title": "Test Book 2",
                "quantity": 3,
                "pub_date": "'$TIMESTAMP'"
              }
            ],
            "error_cases": [],
            "total_quantity": 5,
            "run_date": "'$TIMESTAMP'",
            "total_pending_books": 2,
            "test_data": true
          }' > "$FALLBACK_FILE"
          
          echo "releases_file=$FALLBACK_FILE" >> $GITHUB_OUTPUT
          echo "Created fallback pending releases file: $FALLBACK_FILE"
      
      - name: Create approval issue
        id: create-issue
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            let releasesFile = '${{ steps.run-audit.outputs.releases_file || steps.create-fallback.outputs.releases_file }}';
            try {
              // Read the releases file
              const fileContent = fs.readFileSync(releasesFile, 'utf8');
              const pendingData = JSON.parse(fileContent);
              const timestamp = new Date().toISOString().split('T')[0];
              const isTestData = pendingData.test_data === true;
              const testPrefix = isTestData ? '[TEST] ' : '';

              // Load preorder_history.json for deduplication of early arrivals
              let preorderHistory = { reported_preorders: [] };
              const preorderHistoryPath = path.resolve('./preorders/preorder_history.json');
              if (fs.existsSync(preorderHistoryPath)) {
                try {
                  preorderHistory = JSON.parse(fs.readFileSync(preorderHistoryPath, 'utf8'));
                  if (!Array.isArray(preorderHistory.reported_preorders)) preorderHistory.reported_preorders = [];
                } catch (e) {
                  preorderHistory = { reported_preorders: [] };
                }
              }
              const reportedIsbns = new Set(preorderHistory.reported_preorders.map(r => r.isbn));

              // Helper function to format dates as "Month DD, YYYY"
              function formatDate(dateStr) {
                if (!dateStr || dateStr === 'Unknown') return 'Unknown';
                try {
                  const options = { year: 'numeric', month: 'long', day: 'numeric' };
                  const date = new Date(dateStr);
                  if (!isNaN(date.getTime())) {
                    return date.toLocaleDateString('en-US', options);
                  }
                  return dateStr;
                } catch (e) {
                  return dateStr;
                }
              }

              function bookRow(book, index = 0, opts = {}) {
                // opts: { includeCheckbox: bool, includeReason: bool }
                const checkbox = opts.includeCheckbox ? '| [ ] ' : '';
                // Conditional formatting: include Reason column only if book.reason is present or includeReason is true
                let reason = '';
                if (opts.includeReason) {
                  reason = `| ${book.reason ? book.reason : ''} `;
                }
                return `${checkbox}| ${index + 1} | ${book.isbn || ''} | ${book.title || ''} | ${book.quantity ?? book.presold_qty ?? ''} | ${book.inventory ?? ''} | ${formatDate(book.pub_date)} | ${book.tagged ?? ''} | ${book.in_collection ?? ''} ${reason}|\n`;
              }

              function booksTable(books, opts = {}) {
                // Columns: | [Approve] | # | ISBN | Title | Presold QTY | Inventory | Pub Date | Tagged | In Collection | [Reason] |
                let header = '';
                if (opts.includeCheckbox) {
                  header += '| Approve ';
                }
                header += '| # | ISBN | Title | Presold QTY | Inventory | Pub Date | Tagged | In Collection ';
                // Only show Reason column if at least one book has a reason or opts.includeReason is true
                if (opts.includeReason) header += '| Reason ';
                header += '|\n';
                // Table separator
                if (opts.includeCheckbox) {
                  header += '|---------';
                }
                header += '|----|------|-------|------------|-----------|----------|--------|--------------';
                if (opts.includeReason) header += '|--------';
                header += '|\n';
                // Table rows
                let rows = '';
                books.forEach((book, i) => {
                  rows += bookRow(book, i, opts);
                });
                return header + rows;
              }

              // Section 1: Approved Preorder Titles for This Week
              let releaseThisWeek = Array.isArray(pendingData.release_this_week) ? pendingData.release_this_week : [];
              // Section 2: Preorder Titles Releasing Next Week
              let releasesNextWeek = Array.isArray(pendingData.releases_next_week) ? pendingData.releases_next_week : [];
              // Section 3: 🚨 Early Stock Arrivals
              let earlyStockArrivals = Array.isArray(pendingData.early_stock_arrivals) ? pendingData.early_stock_arrivals : [];
              // Section 4: ⚠️ Issues Requiring Attention
              let anomalies = Array.isArray(pendingData.anomalies) ? pendingData.anomalies : [];
              // Section 5: 📊 All Preorders (League Table)
              let allPreorders = Array.isArray(pendingData.all_preorders) ? pendingData.all_preorders : [];

              // --- FILTERS AND REASON LOGIC ---
              // Remove items already reported from earlyStockArrivals
              earlyStockArrivals = earlyStockArrivals.filter(book => !reportedIsbns.has(book.isbn));

              // Reason logic for early stock arrivals
              // Try to infer the reason from override history, audit, or fallback field
              function getEarlyReason(book) {
                // If book.reason is already set, use it
                if (book.reason) return book.reason;
                // Check for override or audit fields
                // (Assume audit/override info is in book.override_history or book.audit_info if present)
                if (book.override_history && Array.isArray(book.override_history) && book.override_history.length > 0) {
                  // Use the latest override entry
                  const latest = book.override_history[book.override_history.length - 1];
                  if (latest && latest.action && latest.action.includes('removed from preorder collection')) {
                    return 'In stock early; removed from preorder collection';
                  }
                  if (latest && latest.action && latest.action.includes('pub date overridden')) {
                    return `Pub date overridden to ${formatDate(latest.new_pub_date)}`;
                  }
                }
                if (book.audit_info && book.audit_info.reason) {
                  return book.audit_info.reason;
                }
                // Fallback: if the book was previously in the preorder collection but now not, or has inventory and future pub_date
                if (book.in_collection === false && book.inventory > 0 && new Date(book.pub_date) > new Date()) {
                  return 'In stock early; removed from preorder collection';
                }
                if (book.pub_date_override && book.pub_date_override !== book.pub_date) {
                  return `Pub date overridden to ${formatDate(book.pub_date_override)}`;
                }
                // Fallback to blank
                return '';
              }
              // Attach reason to each earlyStockArrival
              earlyStockArrivals = earlyStockArrivals.map(book => ({
                ...book,
                reason: getEarlyReason(book)
              }));

              // Remove items already reported from anomalies as well
              anomalies = anomalies.filter(book => !reportedIsbns.has(book.isbn));

              // --- END FILTERS AND REASON LOGIC ---

              // Sort allPreorders by pub date ascending (respecting overrides)
              allPreorders = allPreorders.slice().sort((a, b) => {
                const dateA = a.pub_date_override || a.pub_date;
                const dateB = b.pub_date_override || b.pub_date;
                if (!dateA) return 1;
                if (!dateB) return -1;
                return (dateA > dateB) ? 1 : (dateA < dateB ? -1 : 0);
              });

              // Section 1: This week's releases (with checkbox, respect pub_date_override)
              releaseThisWeek = releaseThisWeek.filter(book => {
                const pubDate = book.pub_date_override || book.pub_date;
                // Already filtered upstream, but double-check: Only include if not already reported
                return !reportedIsbns.has(book.isbn) && pubDate;
              });
              // Section 2: Next week's releases (respect pub_date_override)
              releasesNextWeek = releasesNextWeek.filter(book => {
                const pubDate = book.pub_date_override || book.pub_date;
                return !reportedIsbns.has(book.isbn) && pubDate;
              });
              // Section 4: anomalies (respect pub_date_override)
              anomalies = anomalies.map(book => {
                // Attach reason if present
                let reason = book.reason || '';
                if (!reason && book.audit_info && book.audit_info.reason) {
                  reason = book.audit_info.reason;
                }
                return { ...book, reason };
              });

              // Issue title
              const issueTitle = `${testPrefix}📚 Preorder Approval: ${releaseThisWeek.length} Books Ready for Release (${timestamp})`;

              // Issue body
              let issueBody = `## Preorder Books Ready for Release Approval


            **Important: Please review these preorder books before they are included in the weekly sales report.**

            Check the boxes for books that should be included in this week's report. Books with unchecked boxes will remain in preorder status.

              ### Instructions
              1. Review each book's details
              2. Check the box in the "Approve" column for books that should be included
                - IMPORTANT: Use exactly \`[x]\` for approved books (lowercase x, no spaces)
              3. Add the label \`approved\` to this issue when you've finished reviewing
              4. Only checked books will have their sales included in the next report
              `;
              // Section 1: This week's releases (with checkbox)
              issueBody += `\n### **Approved Preorder Titles for This Week**\n\n`;
              if (releaseThisWeek.length > 0) {
                issueBody += booksTable(releaseThisWeek, { includeCheckbox: true });
              } else {
                issueBody += '_No books releasing this week._\n';
              }

              // Section 2: Next week's releases (no checkbox)
              issueBody += `\n### **Preorder Titles Releasing Next Week**\n\n`;
              if (releasesNextWeek.length > 0) {
                issueBody += booksTable(releasesNextWeek, { includeCheckbox: false });
              } else {
                issueBody += '_No books releasing next week._\n';
              }

              // Section 3: Early stock arrivals (reason column, includeReason: true if reason present)
              issueBody += `\n### 🚨 Early Stock Arrivals\n\n`;
              if (earlyStockArrivals.length > 0) {
                // Only includeReason if at least one row has a reason
                const includeReason = earlyStockArrivals.some(b => b.reason && b.reason.trim().length > 0);
                issueBody += booksTable(earlyStockArrivals, { includeCheckbox: false, includeReason });
              } else {
                issueBody += '_No early stock arrivals detected._\n';
              }

              // Section 4: Issues Requiring Attention (reuse existing formatting, includeReason: true if reason present)
              issueBody += `\n### ⚠️ Issues Requiring Attention\n\n`;
              if (anomalies.length > 0) {
                const includeReason = anomalies.some(b => b.reason && b.reason.trim().length > 0);
                issueBody += booksTable(anomalies, { includeCheckbox: false, includeReason });
              } else {
                issueBody += '_No anomalies detected._\n';
              }

              // Section 5: All Preorders (League Table)
              issueBody += `\n### 📊 All Preorders (League Table)\n\n`;
              if (allPreorders.length > 0) {
                issueBody += booksTable(allPreorders, { includeCheckbox: false });
              } else {
                issueBody += '_No preorders found._\n';
              }

              // Notes section
              issueBody += `

              ### Notes
              - This approval is required by: Monday at 8:00 AM
              - Books not approved will remain in preorder status
              - Data file: \`${releasesFile}\`
              ${isTestData ? '- ⚠️ THIS IS A TEST ISSUE WITH SIMULATED DATA ⚠️' : ''}`;

              // Create the issue
              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issueTitle,
                body: issueBody,
                labels: ['pending-approval', 'preorders', ...(isTestData ? ['test-data'] : [])]
              });
              console.log(`Created approval issue #${issue.data.number}`);
              return issue.data.number;
            } catch (error) {
              console.error(`Error creating approval issue: ${error}`);
              console.error(error.stack);
              core.setFailed(`Failed to create approval issue: ${error.message}`);
            }
      
      - name: Upload tracking artifacts
        uses: actions/upload-artifact@v4
        with:
          name: tracking-and-approvals-${{ github.run_id }}
          path: |
            preorders/NYT_preorder_tracking.csv
            output/approved_releases_*.json
            preorders/preorder_history.json
          retention-days: 30

      - name: Save pending releases file
        uses: actions/upload-artifact@v4
        with:
          name: pending-releases-${{ github.run_id }}
          path: ${{ steps.run-audit.outputs.releases_file || steps.create-fallback.outputs.releases_file }}
          retention-days: 7

  generate-report:
    needs: determine-job
    if: needs.determine-job.outputs.job_type == 'generate-report' || needs.determine-job.outputs.job_type == 'full'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Create environment file
        run: |
          echo "SHOP_URL=${{ secrets.SHOP_URL }}" > .env.production
          echo "SHOPIFY_ACCESS_TOKEN=${{ secrets.SHOPIFY_ACCESS_TOKEN }}" >> .env.production
          echo "MAILTRAP_API_TOKEN=${{ secrets.MAILTRAP_API_TOKEN }}" >> .env.production
          echo "EMAIL_SENDER=${{ secrets.EMAIL_SENDER }}" >> .env.production
          echo "EMAIL_RECIPIENTS=${{ secrets.EMAIL_RECIPIENTS }}" >> .env.production
          
          # Set test mode based on input parameter
          if [ "${{ github.event.inputs.run_mode }}" = "test" ]; then
            echo "USE_TEST_DATA=true" >> .env.production
            echo "🧪 Running in TEST mode"
          else
            echo "USE_TEST_DATA=false" >> .env.production
            echo "🚀 Running in PRODUCTION mode"
          fi
      
      - name: Check for approved issues or manual overrides
        id: check-approvals
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Check for manual ISBN override
            const manualISBNs = '${{ github.event.inputs.isbn_list }}';
            if (manualISBNs && manualISBNs.trim() !== '') {
              console.log("Using manual ISBN list: " + manualISBNs);
              return {
                status: 'manual_override',
                isbns: manualISBNs.split(',').map(isbn => isbn.trim()),
                issue_number: null
              };
            }
            
            // Check for manual issue number
            const manualIssueNumber = '${{ github.event.inputs.issue_number }}';
            if (manualIssueNumber && manualIssueNumber.trim() !== '') {
              try {
                const issueNumber = parseInt(manualIssueNumber.trim());
                const issue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                
                console.log(`Using manually specified issue #${issueNumber}`);
                return {
                  status: 'manual_issue',
                  issue_number: issueNumber,
                  isbns: []
                };
              } catch (error) {
                console.error(`Error getting issue #${manualIssueNumber}: ${error.message}`);
              }
            }
            
            // Find open issues with pending-approval label
            const pendingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'pending-approval'
            });
            
            if (pendingIssues.data.length > 0) {
              // Check if any have the 'approved' label
              const approvedIssues = pendingIssues.data.filter(issue => 
                issue.labels.some(label => label.name === 'approved')
              );
              
              if (approvedIssues.length > 0) {
                const issue = approvedIssues[0];
                console.log(`Found approved issue #${issue.number}: ${issue.title}`);
                return {
                  status: 'approved',
                  issue_number: issue.number,
                  isbns: []
                };
              } else {
                console.log("Found pending issues without approval");
                return { status: 'waiting', issue_number: null, isbns: [] };
              }
            } else {
              console.log("No pending approval issues found");
              return { status: 'no_pending', issue_number: null, isbns: [] };
            }
      
      - name: Process approved issue
        id: process-issue
        # Fixed conditional statement
        if: steps.check-approvals.outputs.result != '' && (fromJSON(steps.check-approvals.outputs.result).status == 'approved' || fromJSON(steps.check-approvals.outputs.result).status == 'manual_issue')
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            (async () => {
              const fs = require('fs');
              const path = require('path');
              const resultsObj = JSON.parse('${{ steps.check-approvals.outputs.result }}');
              const issueNumber = resultsObj.issue_number;
              // Add fetchLiveInventory function
              const fetchLiveInventory = async (isbn) => {
                try {
                  const query = `
                    query getProductByISBN($query: String!) {
                      products(first: 1, query: $query) {
                        edges {
                          node {
                            variants(first: 1) {
                              edges {
                                node {
                                  inventoryQuantity
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  `;
                  const result = await github.request('POST /graphql', {
                    headers: {
                      'X-GitHub-Api-Version': '2022-11-28',
                      'Content-Type': 'application/json'
                    },
                    data: {
                      query,
                      variables: { query: `barcode:${isbn}` }
                    }
                  });
                  const quantity = result.data.products.edges[0]?.node.variants.edges[0]?.node.inventoryQuantity;
                  return typeof quantity === 'number' ? quantity : 0;
                } catch (e) {
                  console.log(`Error fetching live inventory for ISBN ${isbn}:`, e.message);
                  return 0;
                }
              };
              try {
                // Get the issue
                const issue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                console.log(`Processing issue #${issueNumber}: ${issue.data.title}`);
                // Save issue body to file
                fs.writeFileSync('./issue_body.txt', issue.data.body);
                if (!fs.existsSync('./output')) {
                  fs.mkdirSync('./output', { recursive: true });
                }
                // Extract the pending releases file path from the issue body
                const releasesMatch = issue.data.body.match(/Data file: `(.+?)`/);
                let releasesFile = null;
                if (releasesMatch && releasesMatch[1]) {
                  releasesFile = releasesMatch[1];
                  console.log(`Found releases file reference in issue: ${releasesFile}`);
                } else {
                  console.log("Could not find releases file reference in issue body");
                }
                // Parse the issue body to extract approved books (lines with [x])
                const lines = issue.data.body.split('\n');
                const approvedBooks = [];
                for (const line of lines) {
                  // Match lines that have a checked box in a table row format
                  if (line.match(/\|\s*\[x\]/i)) {
                    // Extract ISBN from the line (second column in the table)
                    const match = line.match(/\|\s*\[x\]\s*\|\s*([0-9]+)/i);
                    if (match) {
                      const isbn = match[1];
                      console.log(`Found approved ISBN: ${isbn}`);
                      approvedBooks.push(isbn);
                    }
                  }
                }
                console.log(`Total approved ISBNs found: ${approvedBooks.length}`);
                // Helper function to convert formatted date back to ISO format
                function parseDateToISO(formattedDate) {
                  if (!formattedDate || formattedDate === 'Unknown') return '';
                  try {
                    const date = new Date(formattedDate);
                    if (!isNaN(date.getTime())) {
                      return date.toISOString().split('T')[0];
                    }
                    return formattedDate;
                  } catch (e) {
                    console.log(`Error parsing date ${formattedDate}: ${e}`);
                    return formattedDate;
                  }
                }
                // Extract details for each approved book (refactored logic)
                const approvedDetails = [];
                for (const line of lines) {
                  for (const isbn of approvedBooks) {
                    if (line.includes(isbn)) {
                      const columns = line.split('|').map(col => col.trim());
                      if (columns.length >= 7) {
                        // Extracted title from column 3 (not 2)
                        const extractedTitle = columns[3] || `Book with ISBN ${isbn}`;
                        // Quantity from column 4
                        const presoldQty = parseInt(columns[4]) || 0;
                        // Inventory from column 5 (now live inventory)
                        const currentInventory = await fetchLiveInventory(isbn);
                        // Pub date: prefer override if available, fallback to parsed ISO date from column 6
                        const formattedPubDate = columns[6] || '';
                        const pubDate = parseDateToISO(formattedPubDate);
                        approvedDetails.push({
                          isbn: isbn,
                          title: extractedTitle,
                          quantity: presoldQty,
                          inventory: currentInventory,
                          pub_date: pubDate,
                          formatted_pub_date: formattedPubDate
                        });
                        console.log(`Extracted details for ISBN ${isbn}: Title=${extractedTitle}, Quantity=${presoldQty}, Inventory=${currentInventory}, Pub Date=${pubDate}`);
                        break;
                      }
                    }
                  }
                }
                // Check if this is a test issue
                const isTestData = issue.data.labels.some(label => label.name === 'test-data');
                // Create approved releases file
                const timestamp = new Date().toISOString().split('T')[0];
                const approvedReleases = {
                  approved_releases: approvedDetails.map(book => ({
                    ...book,
                    approved: true,
                    approval_date: timestamp
                  })),
                  total_approved_books: approvedDetails.length,
                  total_approved_quantity: approvedDetails.reduce((sum, book) => sum + (book.quantity || 0), 0),
                  approval_date: timestamp,
                  test_data: isTestData
                };
                // Save the approved releases file
                const outputFile = `./output/approved_releases_${timestamp}.json`;
                fs.writeFileSync(outputFile, JSON.stringify(approvedReleases, null, 2));
                console.log(`Created approved releases file: ${outputFile}`);
                console.log(`Approved books: ${approvedReleases.approved_releases.length}`);
                console.log(`Total quantity: ${approvedReleases.total_approved_quantity}`);
                console.log(`Is test data: ${isTestData}`);

                // --- BEGIN: Update preorder_history.json with approved books ---
                const historyPath = path.resolve('./preorders/preorder_history.json');
                let history = { reported_preorders: [], last_updated: "" };
                if (fs.existsSync(historyPath)) {
                  try {
                    history = JSON.parse(fs.readFileSync(historyPath, 'utf8'));
                    if (!Array.isArray(history.reported_preorders)) history.reported_preorders = [];
                  } catch (err) {
                    console.log("Could not parse preorder_history.json, resetting file.");
                    history = { reported_preorders: [], last_updated: "" };
                  }
                }
                // Append new approved releases if not already present
                for (const approved of approvedReleases.approved_releases) {
                  if (!history.reported_preorders.some(r => r.isbn === approved.isbn)) {
                    history.reported_preorders.push({
                      isbn: approved.isbn,
                      title: approved.title || '',
                      quantity: approved.quantity || 0,
                      inventory: approved.inventory || 0,
                      pub_date: approved.pub_date || '',
                      report_date: timestamp,
                      added: new Date().toISOString()
                    });
                  }
                }
                // Update timestamp
                history.last_updated = new Date().toISOString();
                fs.writeFileSync(historyPath, JSON.stringify(history, null, 2));
                console.log(`Updated preorder_history.json with approved releases.`);
                // --- END: Update preorder_history.json ---

                // Close the issue and add processed label
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  state: 'closed',
                  labels: [...issue.data.labels.map(label => label.name), 'processed']
                });
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: `✅ Approved books have been processed and will be included in the weekly report.`
                });
                return {
                  approved_file: outputFile,
                  approved_books: approvedReleases.approved_releases.length,
                  is_test_data: isTestData
                };
              } catch (error) {
                console.error(`Error processing issue #${issueNumber}: ${error.message}`);
                console.error(error.stack);
                core.setFailed(`Error processing issue: ${error.message}`);
              }
            })();
      
      - name: Process manual ISBN override
        id: process-override
        # Fixed conditional statement
        if: steps.check-approvals.outputs.result != '' && fromJSON(steps.check-approvals.outputs.result).status == 'manual_override'
        run: |
          # Create a file with approved ISBNs
          mkdir -p output
          TIMESTAMP=$(date +'%Y-%m-%d')
          APPROVED_FILE="./output/approved_releases_${TIMESTAMP}.json"

          # Get the list of ISBNs from the input
          RESULT='${{ steps.check-approvals.outputs.result }}'
          ISBNS=$(echo $RESULT | jq -r '.isbns | join(",")')
          IFS=',' read -ra ISBN_ARRAY <<< "$ISBNS"

          # Start creating the JSON file
          echo "{" > "$APPROVED_FILE"
          echo '  "approved_releases": [' >> "$APPROVED_FILE"

          # Add each ISBN as an entry
          for i in "${!ISBN_ARRAY[@]}"; do
            ISBN="${ISBN_ARRAY[$i]}"
            echo "Processing ISBN: $ISBN"

            # Add comma for all but the last entry
            if [ $i -gt 0 ]; then
              echo "," >> "$APPROVED_FILE"
            fi

            # Add the book entry
            echo "    {" >> "$APPROVED_FILE"
            echo "      \"isbn\": \"$ISBN\"," >> "$APPROVED_FILE"
            echo "      \"title\": \"Manual Override Book $((i+1))\"," >> "$APPROVED_FILE"
            echo "      \"quantity\": 5," >> "$APPROVED_FILE"
            echo "      \"approved\": true," >> "$APPROVED_FILE"
            echo "      \"approval_date\": \"$TIMESTAMP\"" >> "$APPROVED_FILE"
            echo -n "    }" >> "$APPROVED_FILE"
          done

          # Close the JSON structure
          echo "" >> "$APPROVED_FILE"
          echo "  ]," >> "$APPROVED_FILE"
          echo "  \"total_approved_books\": ${#ISBN_ARRAY[@]}," >> "$APPROVED_FILE"
          echo "  \"total_approved_quantity\": $((${#ISBN_ARRAY[@]} * 5))," >> "$APPROVED_FILE"
          echo "  \"approval_date\": \"$TIMESTAMP\"," >> "$APPROVED_FILE"

          # Check if we're in test mode
          if [ "${{ github.event.inputs.run_mode }}" = "test" ]; then
            echo "  \"test_data\": true" >> "$APPROVED_FILE"
          else
            echo "  \"test_data\": false" >> "$APPROVED_FILE"
          fi

          echo "}" >> "$APPROVED_FILE"

          echo "Created manual override approved releases file: $APPROVED_FILE"
          echo "approved_file=$APPROVED_FILE" >> $GITHUB_OUTPUT
      
      - name: Create fallback approved releases if needed
        id: create-fallback-approved
        # Fixed conditional statement
        if: steps.check-approvals.outputs.result != '' && fromJSON(steps.check-approvals.outputs.result).status == 'no_pending' && github.event.inputs.run_mode == 'test'
        run: |
          mkdir -p output
          TIMESTAMP=$(date +'%Y-%m-%d')
          APPROVED_FILE="./output/approved_releases_${TIMESTAMP}.json"
          
          echo '{
            "approved_releases": [
              {
                "isbn": "9780262551311",
                "title": "Fallback Test Book 1",
                "quantity": 2,
                "approved": true,
                "approval_date": "'$TIMESTAMP'"
              },
              {
                "isbn": "9784756256522",
                "title": "Fallback Test Book 2",
                "quantity": 3,
                "approved": true,
                "approval_date": "'$TIMESTAMP'"
              }
            ],
            "total_approved_books": 2,
            "total_approved_quantity": 5,
            "approval_date": "'$TIMESTAMP'",
            "test_data": true
          }' > "$APPROVED_FILE"
          
          echo "Created fallback approved releases file: $APPROVED_FILE"
          echo "approved_file=$APPROVED_FILE" >> $GITHUB_OUTPUT
      
      - name: Verify preorder history file
        run: |
          mkdir -p preorders
          
          # Check if preorder history file exists
          if [ ! -f "./preorders/preorder_history.json" ]; then
            echo "Creating initial preorder history file"
            echo '{
              "reported_preorders": [],
              "last_updated": "'$(date -Iseconds)'"
            }' > ./preorders/preorder_history.json
          fi
          
          echo "Preorder history file contents:"
          cat ./preorders/preorder_history.json || echo "Could not display history file"
      
      - name: Verify files in output directory
        run: |
          echo "Files in output directory:"
          ls -la ./output/
          
          echo "Checking for approved_releases files:"
          find ./output -name "approved_releases_*.json" || echo "No approved_releases files found"
      
      - name: Commit preorder history updates
        if: github.event.inputs.run_mode != 'test'
        run: |
          # Force update the timestamp in the preorder history file to ensure there's a change
          python -c "import json, os, datetime; file_path = './preorders/preorder_history.json'; data = json.load(open(file_path, 'r')) if os.path.exists(file_path) else {'reported_preorders': [], 'last_updated': ''}; data['last_updated'] = datetime.datetime.now().isoformat(); open(file_path, 'w').write(json.dumps(data, indent=2)); print('Updated timestamp in preorder history file')"
          
          # Verify the file exists and commit changes
          if [ -f "./preorders/preorder_history.json" ]; then
            echo "Preorder history file exists, preparing to commit"
            git config --local user.email "github-actions@github.com"
            git config --local user.name "GitHub Actions"
            git add ./preorders/preorder_history.json
            git commit -m "Update preorder history after processing releases [skip ci]" || echo "No changes to commit"
            git push || echo "Failed to push changes"
            echo "Commit and push operation completed"

            # Verify that the local and remote commit hashes match
            LOCAL_COMMIT=$(git rev-parse HEAD)
            REMOTE_COMMIT=$(git ls-remote origin HEAD | awk '{ print $1 }')

            echo "Local commit: $LOCAL_COMMIT"
            echo "Remote commit: $REMOTE_COMMIT"

            if [ "$LOCAL_COMMIT" != "$REMOTE_COMMIT" ]; then
              echo "❌ Commit verification failed: Local and remote commits do not match."
              curl -X POST -H 'Content-type: application/json' \
                --data '{"text":"🚨 GitHub Actions Alert: Commit verification failed for preorder_history.json. Manual intervention may be required."}' \
                ${{ secrets.SLACK_WEBHOOK_URL }}
              exit 1
            else
              echo "✅ Commit successfully pushed and verified."
            fi
          else
            echo "Preorder history file not found at ./preorders/preorder_history.json"
          fi

      - name: Run weekly sales report
        id: run-report
        run: |
          # Set a flag to indicate this is a manual run if applicable
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "MANUAL_RUN=true" >> $GITHUB_ENV
          fi
          
          # Verify preorder history file exists and has valid structure
          echo "Verifying preorder history file..."
          mkdir -p preorders
          HISTORY_FILE="./preorders/preorder_history.json"
          
          if [ ! -f "$HISTORY_FILE" ]; then
            echo "Creating initial preorder history file"
            echo '{
              "reported_preorders": [],
              "last_updated": "'$(date -Iseconds)'"
            }' > "$HISTORY_FILE"
          else
            # Verify it's valid JSON
            if ! jq . "$HISTORY_FILE" > /dev/null 2>&1; then
              echo "Invalid JSON in history file, creating backup and resetting"
              cp "$HISTORY_FILE" "${HISTORY_FILE}.bak.$(date +%Y%m%d%H%M%S)"
              echo '{
                "reported_preorders": [],
                "last_updated": "'$(date -Iseconds)'"
              }' > "$HISTORY_FILE"
            fi
          fi
          
          # Check output directory
          mkdir -p output
          
          # List directories for debugging
          echo "Current directory contents:"
          ls -la ./
          
          echo "Preorders directory contents:"
          ls -la ./preorders/
          
          echo "Output directory contents:"
          ls -la ./output/
          
          # Check for approved releases files
          APPROVED_FILES=$(find ./output -name "approved_releases_*.json" | sort -r)
          if [ -n "$APPROVED_FILES" ]; then
            echo "Found approved releases files:"
            echo "$APPROVED_FILES"
            
            # Check if the latest file is valid JSON
            LATEST_FILE=$(echo "$APPROVED_FILES" | head -n1)
            echo "Validating latest file: $LATEST_FILE"
            if ! jq . "$LATEST_FILE" > /dev/null 2>&1; then
              echo "WARNING: Latest approved releases file contains invalid JSON!"
            else
              echo "Latest approved releases file is valid JSON"
            fi
          else
            echo "No approved releases files found"
          fi
          
          # Run the weekly report with better error handling
          echo "Running weekly sales report..."
          set +e  # Don't exit on error
          python -u weekly_sales_report.py
          REPORT_EXIT_CODE=$?
          set -e  # Restore exit on error
          
          if [ $REPORT_EXIT_CODE -ne 0 ]; then
            echo "ERROR: Weekly sales report script exited with code $REPORT_EXIT_CODE"
            echo "Checking for errors in log output..."
            
            # Try to find error messages in recent logs
            if [ -f "./preorders/preorder_history.json" ]; then
              echo "Preorder history file contents:"
              cat "./preorders/preorder_history.json"
            fi
            
            # Create an error report
            echo "Creating error report..."
            {
              echo "=== ERROR REPORT ==="
              echo "Exit code: $REPORT_EXIT_CODE"
              echo "Date: $(date)"
              echo ""
              echo "=== DIRECTORY STRUCTURE ==="
              echo "Root directory:"
              ls -la ./ || echo "Failed to list root directory"
              echo ""
              echo "Preorders directory:"
              ls -la ./preorders/ || echo "Failed to list preorders directory"
              echo ""
              echo "Output directory:"
              ls -la ./output/ || echo "Failed to list output directory"
              echo ""
              
              # Include latest approved releases file if it exists
              if [ -n "$LATEST_FILE" ]; then
                echo "=== LATEST APPROVED RELEASES FILE ==="
                echo "File: $LATEST_FILE"
                cat "$LATEST_FILE" || echo "Failed to read file"
              fi
              
              echo ""
              echo "=== PREORDER HISTORY FILE ==="
              cat "$HISTORY_FILE" || echo "Failed to read preorder history file"
            } > "error_report_$(date +%Y%m%d%H%M%S).txt"
            
            echo "Error report created. Weekly report script failed."
            exit 1
          fi
          
          # Check if report was generated
          REPORT_FILE=$(find ./output -name "NYT_weekly_sales_report_*.csv" | sort -r | head -n1)
          if [ -n "$REPORT_FILE" ]; then
            echo "report_file=$REPORT_FILE" >> $GITHUB_OUTPUT
            echo "Weekly report successfully generated: $REPORT_FILE"
          else
            echo "No report file was generated!"
            exit 1
          fi
      
      - name: Upload report results
        uses: actions/upload-artifact@v4
        with:
          name: weekly-report-${{ github.run_id }}
          path: |
            ./output/NYT_weekly_sales_report_*.csv
            ./output/NYT_excluded_items_*.csv
            ./preorders/NYT_preorder_tracking.csv
          retention-days: 30

      - name: Commit updated NYT preorder tracking
        if: github.event.inputs.run_mode != 'test'
        run: |
          if [ -f "./preorders/NYT_preorder_tracking.csv" ]; then
            echo "Preparing to commit updated NYT_preorder_tracking.csv"
            git config --local user.email "github-actions@github.com"
            git config --local user.name "GitHub Actions"
            git add ./preorders/NYT_preorder_tracking.csv
            git commit -m "Update NYT preorder tracking file after weekly report [skip ci]" || echo "No changes to commit"
            git push || echo "Failed to push changes"

            # Verify the commit hash
            LOCAL_COMMIT=$(git rev-parse HEAD)
            REMOTE_COMMIT=$(git ls-remote origin HEAD | awk '{ print $1 }')
            echo "Local commit: $LOCAL_COMMIT"
            echo "Remote commit: $REMOTE_COMMIT"

            if [ "$LOCAL_COMMIT" != "$REMOTE_COMMIT" ]; then
              echo "❌ Commit verification failed: Local and remote commits do not match."
              curl -X POST -H 'Content-type: application/json' \
                --data '{"text":"🚨 GitHub Actions Alert: Commit verification failed for NYT_preorder_tracking.csv. Manual intervention may be required."}' \
                ${{ secrets.SLACK_WEBHOOK_URL }}
              exit 1
            else
              echo "✅ Commit successfully pushed and verified."
            fi
          else
            echo "NYT_preorder_tracking.csv not found; skipping commit step."
          fi
